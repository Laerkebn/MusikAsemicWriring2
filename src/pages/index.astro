---
import Layout from "../layouts/Layout.astro";
import "../styles.css";
import Udseene from "./udseene.astro";
import Soft from "./soft.astro";
import Rough from "./rough.astro";
---

<!DOCTYPE html>
<html lang="da">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tone → SVG Generator</title>
  <script src="https://cdn.tailwindcss.com"></script>
<link rel="icon" type="image/svg+xml" href="/billeder/favicon.svg" />


</head>


<body>
    <Soft />
    <Rough />
    <Udseene />



  <script type="module">
// ==========================================
// FADE FUNKTION
// ==========================================
/**
 * Anvender en fade-out effekt på en SVG-node over tid.
 * 
 * @param {SVGElement} svgEl - SVG-elementet der skal fade ud
 * @param {number} size - Størrelsen af SVG'en (bruges til at skalere alpha-værdien)
 * 
 * Funktionen virker ved at:
 * 1. Initialisere en "_life" property på 1.0 (100% synlighed)
 * 2. Reducere _life med 0.01 per frame (via requestAnimationFrame)
 * 3. Mappe størrelsen til en alpha-multiplikator (store SVG'er fader langsommere)
 * 4. Fjerne elementet når opacity når 0
 */
function applyFadeOut(svgEl, size) {
  // mapValue er en utility-funktion der fungerer som p5.js' map()
  // Den konverterer en værdi fra ét interval til et andet
  // Eksempel: mapValue(150, 2, 300, 1.0, 0.2) 
  // → mapper 150 fra range [2-300] til range [1.0-0.2]
  function mapValue(value, inMin, inMax, outMin, outMax) {
    return outMin + ((value - inMin) * (outMax - outMin)) / (inMax - inMin);
  }

  // Gem initial state på selve SVG-elementet
  svgEl._life = 20;      // 100% liv/opacity
  svgEl._size = size;     // Original størrelse (bruges til alpha-beregning)

  // Rekursiv animation-funktion der kører hver frame
  function fade() {
    // Sikkerhedscheck: Stop hvis elementet er fjernet fra DOM
    if (!svgEl.parentNode) return;

    // Reducer livstiden med 1% per frame (~60fps = ~1.67 sek total fade)
    svgEl._life -= 0.01;

    // Beregn alpha baseret på størrelse:
    // - Store SVG'er (300px) får alphaSize = 0.2 (fader hurtigere)
    // - Små SVG'er (2px) får alphaSize = 1.0 (fader langsommere)
    // Dette skaber dynamisk fade-hastighed baseret på størrelse
    const alphaSize = mapValue(svgEl._size, 2, 300, 1.0, 0.2);
    
    // Final alpha er produktet af størrelse-skaleret alpha og livstid
    const alpha = alphaSize * svgEl._life;

    // Anvend opacity direkte på elementet
    svgEl.style.opacity = alpha;

    // Når alpha når 0 eller under, fjern elementet helt fra DOM
    if (alpha <= 0) {
      svgEl.remove();
      return;  // Stop animationen
    }

    // Fortsæt animationen næste frame (rekursivt)
    requestAnimationFrame(fade);
  }

  // Start fade-animationen
  requestAnimationFrame(fade);
}

// ==========================================
// KONSTANTER
// ==========================================

// NOTE_SVG_MAP holder mappingen mellem tonenavn og SVG-fil-stier
// Initialiseres med rough style, men kan skiftes til soft style
let NOTE_SVG_MAP = window.ROUGH_STYLE_MAP; // Defineret i rough.astro
let currentStyle = 'rough';                  // Tracker aktiv style

// Standard tonenavn i kromatisk skala (12 halvtoner)
// Bruges til at konvertere frekvenser til tonenavn
const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

// Minimum tid (ms) mellem to tone-detektioner
// Forhindrer "spam" af samme tone hvis den holdes længe
const MIN_TIME_BETWEEN_NOTES = 100;

// Størrelse af audio buffer chunks (samples)
// Større chunks = mere præcis pitch detection, men højere latency
// 2048 samples @ 44.1kHz = ~46ms latency
const CHUNK_SIZE = 2048;

// Root Mean Square threshold for at filtrere støj væk
// Signaler under denne værdi betragtes som stilhed
const RMS_THRESHOLD = 0.01;

// Correlation threshold for pitch detection
// Højere værdi = mere konservativ/præcis detection (færre falske positiver)
const CORRELATION_THRESHOLD = 0.9;

// SVG størrelses-intervaller (pixels)
const MIN_SVG_SIZE = 10;
const MAX_SVG_SIZE = 300;

// ==========================================
// DOM ELEMENTER
// ==========================================
// Cache alle DOM-referencer for performance

const startMicBtn = document.getElementById("startMic");       // Start mikrofon knap
const stopMicBtn = document.getElementById("stopMic");         // Stop mikrofon knap
const fileInput = document.getElementById("fileInput");        // Fil upload input
const paper = document.getElementById("paper");                // Container til SVG'er
const detectedNoteEl = document.getElementById("detectedNote"); // Viser tonenavn
const centerTextEl = document.getElementById("centerText");    // Bruger-indtastet navn
const detectedFreqEl = document.getElementById("detectedFreq"); // Viser frekvens (Hz)
const intervalInput = document.getElementById("intervalMs");   // Hastighed slider
const speedDisplay = document.getElementById("speedDisplay");  // Hastigheds-display
const colorPicker = document.getElementById("colorPicker");    // Farve-vælger
const softStyleBtn = document.getElementById("softStyleBtn");  // Soft aesthetic knap
const roughStyleBtn = document.getElementById("roughStyleBtn"); // Rough aesthetic knap

// ==========================================
// GLOBALE VARIABLER
// ==========================================

let audioContext;       // Web Audio API context (håndterer al audio processing)
let mediaStreamSource;  // Audio source node fra mikrofon stream
let scriptProcessor;    // ScriptProcessorNode (deprecated men stadig brugt)
let micStream;          // MediaStream objekt fra getUserMedia
let currentColor = "#1E1E1E"; // Aktuel farve for nye SVG'er

// ==========================================
// STYLE SWITCHING
// ==========================================

/**
 * Skifter mellem soft og rough aesthetic styles.
 * 
 * @param {string} style - Enten 'soft' eller 'rough'
 * 
 * Funktionen:
 * 1. Opdaterer NOTE_SVG_MAP til den valgte styles mapping
 * 2. Opdaterer UI-states for knapperne (aktiv/inaktiv)
 * 3. Anvender visuelle styles (farver, disabled state)
 */
function switchStyle(style) {
  // STEP 1: Gem hvilken style der er valgt (enten 'soft' eller 'rough')
  currentStyle = style;
  
  // STEP 2: Tjek om brugeren har klikket på "Soft aesthetic" knappen
  if (style === 'soft') {
    
    // STEP 3: Skift til soft style SVG mapping
    // window.SOFT_STYLE_MAP er defineret i soft.astro komponenten
    NOTE_SVG_MAP = window.SOFT_STYLE_MAP;
    
    // STEP 4: Style "Soft aesthetic" knappen som AKTIV
    // Mørkere baggrund (#9DA2AE) indikerer aktiv state
    softStyleBtn.style.backgroundColor = '#1768F5';  
    softStyleBtn.style.color = '#FFFFF1';            
    softStyleBtn.disabled = true;  // Disable for at forhindre dobbeltklik
    
    // STEP 5: Style "Rough aesthetic" knappen som INAKTIV
    // Lysere baggrund (#D1D5DC) indikerer inaktiv state
    roughStyleBtn.style.backgroundColor = '#D1D5DC'; 
    roughStyleBtn.style.color = '#FFFFF1';         
    roughStyleBtn.disabled = false; // Enable så den kan klikkes
    
  } else {
    // STEP 6: Brugeren har klikket på "Rough aesthetic" knappen
    // STEP 7: Skift til rough style SVG'erne 
    // window.ROUGH_STYLE_MAP er defineret i rough.astro komponenten
    NOTE_SVG_MAP = window.ROUGH_STYLE_MAP;
    
    // STEP 8: Style "Rough aesthetic" knappen som AKTIV
    roughStyleBtn.style.backgroundColor = '#1768F5';
    roughStyleBtn.style.color = '#FFFFF1';
    roughStyleBtn.disabled = true;
    
    // STEP 9: Style "Soft aesthetic" knappen som INAKTIV
    softStyleBtn.style.backgroundColor = '#D1D5DC';
    softStyleBtn.style.color = '#FFFFF1';
    softStyleBtn.disabled = false;
  }
  
  // STEP 10: Log til console så vi kan se det virker (kun for debugging)
  console.log(`Skiftet til ${style} style`);
}

// ==========================================
// HJÆLPEFUNKTIONER
// ==========================================

/**
 * Konverterer en frekvens (Hz) til tonenavn og MIDI-nummer.
 * 
 * @param {number} frequency - Frekvens i Hz (eksempel: 440 = A4)
 * @returns {Object|null} - {name: "A", midi: 69} eller null hvis ugyldig
 * 
 * Algoritme:
 * 1. Bruger formlen: MIDI = 12 × log₂(freq/440) + 69
 *    hvor 69 er MIDI-nummer for A4 (440 Hz)
 * 2. Modulo 12 for at få tonenavn-index (0-11)
 * 3. Mapper index til tonenavn fra NOTE_NAMES array
 */
function freqToNoteName(frequency) {
  // Valider input
  if (!frequency || frequency <= 0) return null;
  
  // Beregn MIDI-nummer fra frekvens
  // Formel: midi = 12 × log₂(f/440) + 69
  // log₂(x) = ln(x) / ln(2) = Math.log2(x)
  const midi = Math.round(12 * (Math.log2(frequency / 440)) + 69);
  
  // Få note index (0-11) via modulo 12
  // Eksempel: MIDI 70 = A# (index 10)
  const noteIndex = midi % 12;
  
  return { 
    name: NOTE_NAMES[noteIndex],  // "C", "C#", etc.
    midi                          // MIDI nummer (0-127)
  };
}

/**
 * Autocorrelation pitch detection algoritme.
 * Finder den dominerende frekvens i et audio buffer.
 * 
 * @param {Float32Array} buffer - Audio samples [-1, 1]
 * @param {number} sampleRate - Sample rate (typisk 44100 eller 48000 Hz)
 * @returns {number} - Frekvens i Hz, eller -1 hvis ingen tone detekteret
 * 
 * Algoritmen:
 * 1. Beregn RMS (Root Mean Square) for at filtrere støj
 * 2. Søg efter det offset der giver bedst correlation
 * 3. Correlation = hvor godt signalet matcher sig selv forskudt i tid
 * 4. Frekvens = sampleRate / offset
 * 
 * Søgeområde: 50-1000 Hz (musikalsk relevant område)
 */
function autoCorrelate(buffer, sampleRate) {
  const SIZE = buffer.length;
  
  // === STEP 1: RMS BEREGNING (støjfiltrering) ===
  // RMS = √(sum(samples²) / count)
  // Måler gennemsnitlig signalstyrke
  let rms = 0;
  for (let i = 0; i < SIZE; i++) {
    rms += buffer[i] * buffer[i];  // Kvadrer hver sample
  }
  rms = Math.sqrt(rms / SIZE);      // Kvadratrod af gennemsnit
  
  // Hvis signalet er for svagt, return -1 (ingen tone)
  if (rms < RMS_THRESHOLD) return -1;

  // === STEP 2: CORRELATION SEARCH ===
  let bestOffset = -1;         // Bedste offset (i samples)
  let bestCorrelation = 0;     // Bedste correlation score
  let lastCorrelation = 1;     // Tracker forrige correlation
  
  // Beregn offset-range baseret på frekvens-range:
  // minOffset = samples per 1000 Hz (højeste tone)
  // maxOffset = samples per 50 Hz (laveste tone)
  const minOffset = Math.floor(sampleRate / 1000);  // ~44 samples @ 44.1kHz
  const maxOffset = Math.floor(sampleRate / 50);    // ~882 samples @ 44.1kHz

  // Scan alle mulige offsets
  for (let offset = minOffset; offset < maxOffset; offset++) {
    let correlation = 0;
    
    // Beregn correlation for dette offset
    // Sammenlign buffer[i] med buffer[i+offset]
    for (let i = 0; i < SIZE - offset; i++) {
      correlation += Math.abs(buffer[i] - buffer[i + offset]);
    }
    
    // Normaliser til [0, 1] hvor 1 = perfekt match
    correlation = 1 - (correlation / SIZE);
    
    // Find peak correlation (skal være over threshold OG højere end forrige)
    // Dette finder fundamentalfrekvensen, ikke overtoner
    if (correlation > CORRELATION_THRESHOLD && correlation > lastCorrelation) {
      if (correlation > bestCorrelation) {
        bestCorrelation = correlation;
        bestOffset = offset;
      }
    }
    lastCorrelation = correlation;
  }
  
  // === STEP 3: BEREGN FREKVENS ===
  // Hvis vi fandt en god correlation, konverter offset til Hz
  if (bestOffset !== -1 && bestCorrelation > CORRELATION_THRESHOLD) {
    // Frekvens = samples per sekund / samples per periode
    return sampleRate / bestOffset;
  }
  
  // Ingen tone fundet
  return -1;
}

/**
 * Henter SVG markup for et specifikt tonenavn.
 * 
 * @param {string} name - Tonenavn ("C", "D#", etc.)
 * @returns {Promise<string|null>} - SVG markup eller null ved fejl
 * 
 * Bruger fetch API til at hente SVG-filer asynkront.
 * NOTE_SVG_MAP indeholder mappings som: {"C": "/svg/soft/C.svg", ...}
 */
async function getSvgForNote(name) {
  // Slå path op i den aktive style mapping
  const path = NOTE_SVG_MAP[name];
  if (!path) return null;  // Tonenavn ikke fundet i mapping
  
  try {
    // Fetch SVG-filen fra server
    const res = await fetch(path);
    if (!res.ok) return null;  // HTTP fejl (404, 500, etc.)
    
    // Returner SVG markup som string
    return await res.text();
  } catch (e) {
    console.error("Kunne ikke hente SVG:", e);
    return null;
  }
}

/**
 * Renderer en tone som SVG på "papiret".
 * 
 * @param {string} name - Tonenavn
 * 
 * Funktionen:
 * 1. Henter SVG markup via getSvgForNote()
 * 2. "Fryser" den aktuelle farve for denne specifikke SVG
 * 3. Fjerner existing styles for at undgå globale CSS-konflikter
 * 4. Sætter farven DIREKTE på hvert path/shape element
 * 5. Positionerer SVG'en tilfældigt på papiret
 * 6. Anvender fade-out animation
 */
async function renderNoteOnPaper(name) {
  const svgHtml = await getSvgForNote(name);
  const wrapper = document.createElement("div");
  
  // === STEP 1: FRYS FARVEN ===
  // Vigtigt! Vi gemmer farven NU, så den ikke ændres hvis brugeren
  // skifter farve mens SVG'en fader ud
  const frozenColor = currentColor;
  
  // === STEP 2: HÅNDTER SVG MARKUP ===
  if (!svgHtml) {
    // Fallback: Simpel firkant med tonenavn hvis SVG ikke kunne hentes
    wrapper.innerHTML = `
      <svg viewBox="0 0 50 50">
        <rect x="5" y="5" width="40" height="40" rx="8" fill="${frozenColor}"/>
        <text x="25" y="32" font-size="14" font-weight="bold" text-anchor="middle" fill="white">${name}</text>
      </svg>
    `;
  } else {
    // Brug den hentede SVG markup
    wrapper.innerHTML = svgHtml;
  }

  const svgEl = wrapper.firstElementChild;
  if (!svgEl) return;  // Sikkerhedscheck

  // === STEP 3: FJERN EKSISTERENDE STYLES ===
  // SVG-filer kan have <style> tags der påvirker ALLE SVG'er på siden
  // Vi fjerner dem for at undgå "bleeding" mellem SVG'er
  const existingStyles = svgEl.querySelectorAll('style');
  existingStyles.forEach(style => style.remove());

  // === STEP 4: ANVEND FARVE DIREKTE ===
  // Sæt stroke/fill DIREKTE på hvert element (ikke via CSS classes)
  // Dette sikrer at hver SVG har sin egen "frosne" farve
  const allElements = svgEl.querySelectorAll('path, line, polyline, polygon, circle, rect, ellipse, g');
  allElements.forEach(el => {
    el.setAttribute('stroke', frozenColor);  // Sæt stroke farve
    el.setAttribute('fill', 'none');         // Ingen fill (kun outline)
    el.removeAttribute('class');             // Fjern classes for at undgå CSS conflicts
  });

  // === STEP 5: BEREGN POSITION OG STØRRELSE ===
  // Tilfældig størrelse mellem MIN og MAX
  const size = Math.floor(Math.random() * (MAX_SVG_SIZE - MIN_SVG_SIZE) + MIN_SVG_SIZE);

  // Papir-dimensioner (liggende A4-format i pixels)
  const paperWidth = 1123;
  const paperHeight = 794;
  
  // Bleed-zone: Hvor meget SVG'er må stikke udenfor kanten
  // Dette skaber en mere naturlig, "bleeding off the page" effekt
  const bleedX = 150;
  const bleedY = 150;

  // Beregn tilfældig position (inkl. bleed-zone)
  // left kan være mellem -150 og 1123 (kan stikke ud til venstre)
  // top kan være mellem -150 og 794 (kan stikke ud foroven)
  const left = Math.random() * (paperWidth + bleedX) - bleedX;
  const top  = Math.random() * (paperHeight + bleedY) - bleedY;

  // === STEP 6: STYLE SVG ELEMENT ===
  Object.assign(svgEl.style, {
    position: "absolute",              // Absolut positionering indenfor #paper
    width: `${size}px`,                // Tilfældig størrelse
    height: `${size}px`,               // Square aspect ratio
    left: `${left}px`,                 // X-position
    top: `${top}px`,                   // Y-position
    animation: "slideIn 0.3s ease-out" // Slide-in animation ved spawn
  });

  // === STEP 7: TILFØJ TIL DOM OG START FADE ===
  paper.appendChild(svgEl);    // Tilføj til paper container
  applyFadeOut(svgEl, size);   // Start fade-out animation
}

/**
 * Opdaterer display af detekteret tone og frekvens.
 * 
 * @param {string} name - Tonenavn
 * @param {number} freq - Frekvens i Hz
 */
function updateDetected(name, freq) {
  detectedNoteEl.textContent = name;           // Vis tonenavn (f.eks. "C#")
  detectedFreqEl.textContent = freq.toFixed(1); // Vis frekvens med 1 decimal (f.eks. "440.0")
}

// ==========================================
// MIKROFON FUNKTIONER
// ==========================================

/**
 * Starter mikrofon-baseret real-time pitch detection.
 * 
 * Flow:
 * 1. Anmod om mikrofon-adgang via getUserMedia
 * 2. Opret Web Audio API processing pipeline
 * 3. Analysér audio chunks løbende med autoCorrelate
 * 4. Render SVG når en tone detekteres
 */
async function startMic() {
  try {
    // === STEP 1: FÅ MIKROFON-ADGANG ===
    // Anmod om audio stream (browser vil spørge om tilladelse)
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    
    // === STEP 2: SETUP WEB AUDIO API ===
    audioContext = new AudioContext();  // Opret audio context
    
    // Opret source node fra mikrofon stream
    mediaStreamSource = audioContext.createMediaStreamSource(micStream);
    
    // Opret script processor node (deprecated, men stadig nødvendigt)
    // CHUNK_SIZE = buffer size, 1 = mono input, 1 = mono output
    scriptProcessor = audioContext.createScriptProcessor(CHUNK_SIZE, 1, 1);
    
    // Connect audio graph: Mikrofon → Processor → Destination
    mediaStreamSource.connect(scriptProcessor);
    scriptProcessor.connect(audioContext.destination);

    // === STEP 3: RATE LIMITING ===
    let lastNoteTime = 0;  // Timestamp af sidste tone detection

    // === STEP 4: AUDIO PROCESSING CALLBACK ===
    // Kaldes automatisk hver gang der er et nyt audio chunk klar
    scriptProcessor.onaudioprocess = async (e) => {
      // Hent audio data fra input buffer (mono = channel 0)
      const buffer = e.inputBuffer.getChannelData(0);
      const now = Date.now();
      
      // Rate limiting: Spring over hvis for tæt på forrige detection
      if (now - lastNoteTime < MIN_TIME_BETWEEN_NOTES) return;

      // Kør pitch detection algoritme
      const freq = autoCorrelate(buffer, audioContext.sampleRate);
      
      // Hvis en tone blev detekteret (freq > 0)
      if (freq > 0) {
        // Konverter frekvens til tonenavn
        const note = freqToNoteName(freq);
        
        if (note?.name) {
          // Render SVG for denne tone
          await renderNoteOnPaper(note.name);
          
          // Opdater UI display
          updateDetected(note.name, freq);
          
          // Opdater timestamp
          lastNoteTime = now;
        }
      }
    };

    // === STEP 5: OPDATER UI ===
    startMicBtn.disabled = true;   // Disable start-knap
    stopMicBtn.disabled = false;   // Enable stop-knap
    
  } catch (e) {
    console.error("Mikrofon fejl:", e);
    alert("Kunne ikke få adgang til mikrofonen.");
  }
}

/**
 * Stopper mikrofon-optagelse og cleaner up ressourcer.
 * 
 * Vigtigt! Web Audio nodes skal disconnectes og streams stoppes
 * for at frigive ressourcer (ellers fortsætter mikrofonen med at lytte)
 */
function stopMic() {
  // Disconnect audio nodes (kan være undefined hvis aldrig startet)
  scriptProcessor?.disconnect();
  mediaStreamSource?.disconnect();
  
  // Stop alle tracks i stream (slukker mikrofonen)
  micStream?.getTracks().forEach(t => t.stop());
  
  // Luk audio context
  audioContext?.close();
  
  // Opdater UI
  startMicBtn.disabled = false;  // Enable start-knap
  stopMicBtn.disabled = true;    // Disable stop-knap
}

// ==========================================
// FIL PROCESSING
// ==========================================

/**
 * Processerer en audio buffer fra en uploadet fil.
 * 
 * @param {AudioBuffer} audioBuffer - Decoded audio data
 * 
 * Flow:
 * 1. Splits audio buffer i chunks
 * 2. Kør pitch detection på hver chunk
 * 3. Render SVG for hver detekteret tone
 * 4. Vent interval mellem hver tone (user-defineret hastighed)
 */
async function processAudioBuffer(audioBuffer) {
  const rate = audioBuffer.sampleRate;      // Sample rate fra filen
  const data = audioBuffer.getChannelData(0); // Mono audio data
  const interval = parseInt(intervalInput.value); // Hastighed (ms) fra slider

  // Iterér gennem audio data i chunks
  for (let i = 0; i < data.length; i += CHUNK_SIZE) {
    // Udtræk en chunk (slice opretter ikke en kopi, bare et view)
    const slice = data.slice(i, i + CHUNK_SIZE);
    
    // Kør pitch detection på denne chunk
    const freq = autoCorrelate(slice, rate);
    
    // Hvis en tone blev detekteret
    if (freq > 0) {
      const note = freqToNoteName(freq);
      
      if (note) {
        // Render SVG
        await renderNoteOnPaper(note.name);
        
        // Opdater UI
        updateDetected(note.name, freq);
        
        // Vent interval før næste iteration (kunstig "playback speed")
        await new Promise(res => setTimeout(res, interval));
      }
    }
  }
}

// ==========================================
// EVENT LISTENERS
// ==========================================

/**
 * Color picker: Opdaterer currentColor når brugeren vælger en ny farve
 */
colorPicker.addEventListener("input", (e) => {
  currentColor = e.target.value;  // Hex color string (f.eks. "#FF5733")
});

/**
 * Interval slider: Opdaterer display-teksten med den valgte hastighed
 */
intervalInput.addEventListener("input", (e) => {
  speedDisplay.textContent = e.target.value;  // Vis ms-værdi
});

/**
 * Style buttons: Skift mellem soft og rough aesthetics
 */
softStyleBtn.addEventListener("click", () => switchStyle('soft'));
roughStyleBtn.addEventListener("click", () => switchStyle('rough'));

/**
 * File input: Håndterer upload af audio filer (.mp3, .wav, etc.)
 * 
 * Flow:
 * 1. Læs fil som ArrayBuffer
 * 2. Decode audio data via Web Audio API
 * 3. Process buffer med pitch detection
 */
fileInput.addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;  // Ingen fil valgt
  
  try {
    // Læs fil som ArrayBuffer (binary data)
    const arrayBuf = await file.arrayBuffer();
    
    // Opret audio context hvis den ikke eksisterer
    audioContext = new AudioContext();
    
    // Decode audio data (konverterer MP3/WAV → PCM samples)
    const audioBuf = await audioContext.decodeAudioData(arrayBuf);
    
    // Process den decoded buffer
    await processAudioBuffer(audioBuf);
    
  } catch (e) {
    console.error("Fil fejl:", e);
    alert("Kunne ikke læse lydfilen.");
  }
});

/**
 * Mikrofon controls
 */
startMicBtn.addEventListener("click", startMic);
stopMicBtn.addEventListener("click", stopMic);

// ==========================================
// GEM SOM SVG
// ==========================================

/**
 * Eksporterer hele "papiret" som en enkelt SVG-fil.
 * 
 * Proces:
 * 1. Opret root SVG element med paper-dimensioner
 * 2. Tilføj baggrund
 * 3. Clone alle doodle-SVG'er og transformer dem korrekt
 * 4. Tilføj brugerens navn i midten (hvis indtastet)
 * 5. Serialiser til string og download som .svg fil
 */
const saveSvgBtn = document.getElementById("saveSvg");

saveSvgBtn.addEventListener("click", () => {
  try {
    // === STEP 1: SETUP ROOT SVG ===
    // Brug samme størrelse som #paper (liggende A4)
    const PAPER_WIDTH = 1123;
    const PAPER_HEIGHT = 794;

    // Opret SVG namespace element (ikke via createElement!)
    const svgWrapper = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svgWrapper.setAttribute("width", PAPER_WIDTH);
    svgWrapper.setAttribute("height", PAPER_HEIGHT);
    svgWrapper.setAttribute("viewBox", `0 0 ${PAPER_WIDTH} ${PAPER_HEIGHT}`);
    svgWrapper.setAttribute("xmlns", "http://www.w3.org/2000/svg");

    // === STEP 2: BAGGRUND ===
    const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    bg.setAttribute("width", PAPER_WIDTH);
    bg.setAttribute("height", PAPER_HEIGHT);
    bg.setAttribute("fill", "#f9fafb");  // Lys grå baggrund
    svgWrapper.appendChild(bg);

    // === STEP 3: CLONE ALLE DOODLE-SVG'ER ===
    const svgs = paper.querySelectorAll("svg");
    svgs.forEach((svg) => {
      const x = parseFloat(svg.style.left) || 0;
      const y = parseFloat(svg.style.top) || 0;
      const width = parseFloat(svg.style.width) || 50;

      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g.setAttribute("transform", `translate(${x}, ${y})`);

      const viewBox = svg.getAttribute("viewBox") || "0 0 50 50";
      const [, , vbW] = viewBox.split(" ").map(Number);
      const scale = width / vbW;

      const innerG = document.createElementNS("http://www.w3.org/2000/svg", "g");
      innerG.setAttribute("transform", `scale(${scale})`);

      Array.from(svg.children).forEach((child) => {
        innerG.appendChild(child.cloneNode(true));
      });

      g.appendChild(innerG);
      svgWrapper.appendChild(g);
    });

    // ==============================
    // Navn + hvid boks i midten
    // ==============================
    if (centerTextEl) {
      let nameText = "";

      // Virker både hvis det er <textarea> eller <div contenteditable>
      if (
        centerTextEl.tagName === "TEXTAREA" ||
        centerTextEl.tagName === "INPUT"
      ) {
        nameText = centerTextEl.value.trim();
      } else {
        nameText = centerTextEl.textContent.trim();
      }

      if (nameText) {
  const paperRect = paper.getBoundingClientRect();
  const textRect = centerTextEl.getBoundingClientRect();

  // Position inde i HTML-papiret
  const rawX = textRect.left - paperRect.left;
  const rawY = textRect.top - paperRect.top;

  // HTML-pixels -> SVG-koordinater
  const scaleX = PAPER_WIDTH / paperRect.width;
  const scaleY = PAPER_HEIGHT / paperRect.height;

  const svgX = rawX * scaleX;
  const svgY = rawY * scaleY;
  const svgWidth = textRect.width * scaleX;
  const svgHeight = textRect.height * scaleY;

  // Hvid boks bag navnet
  const nameBg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  nameBg.setAttribute("x", svgX);
  nameBg.setAttribute("y", svgY);
  nameBg.setAttribute("width", svgWidth);
  nameBg.setAttribute("height", svgHeight);
  nameBg.setAttribute("rx", 12);
  nameBg.setAttribute("ry", 12);
  nameBg.setAttribute("fill", "#ffffff");
  svgWrapper.appendChild(nameBg);

  // Selve navnet i midten
  const nameTextElSvg = document.createElementNS("http://www.w3.org/2000/svg", "text");
  nameTextElSvg.textContent = nameText;
  nameTextElSvg.setAttribute("x", svgX + svgWidth / 2);
  nameTextElSvg.setAttribute("y", svgY + svgHeight / 2);
  nameTextElSvg.setAttribute("text-anchor", "middle");
  nameTextElSvg.setAttribute("dominant-baseline", "middle");
  nameTextElSvg.setAttribute("fill", "#111827");
  nameTextElSvg.setAttribute("font-size", "72");
  nameTextElSvg.setAttribute("font-family", "'Acumin Pro Condensed', sans-serif");
  nameTextElSvg.setAttribute("font-weight", "700");
  svgWrapper.appendChild(nameTextElSvg);
}

    }

    // Gem som fil
    const svgString = new XMLSerializer().serializeToString(svgWrapper);
    const blob = new Blob([svgString], {
      type: "image/svg+xml;charset=utf-8",
    });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, "-");
    link.download = `musikstykke-${currentStyle}-${timestamp}.svg`;
    link.href = url;
    link.click();
    URL.revokeObjectURL(url);
  } catch (e) {
    console.error("SVG fejl:", e);
    alert("Kunne ikke gemme som SVG: " + e.message);
  }
});


    // Initialiser med rough style som aktiv ved opstart
    roughStyleBtn.style.backgroundColor = '#1768F5';
    roughStyleBtn.style.color = '#FFFFF1';
    roughStyleBtn.disabled = true;
    
    softStyleBtn.style.backgroundColor = '#D1D5DC';
    softStyleBtn.style.color = '#FFFFF1';
    softStyleBtn.disabled = false;
  </script>
</body>
</html>