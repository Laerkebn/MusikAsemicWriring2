---
import Layout from "../layouts/Layout.astro";
import "../styles.css";
---

<Layout>
  <style>
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>

  <!-- Titel -->
  <h1 class="text-4xl font-bold text-center mb-8 text-black">
    üéµ Tone ‚Üí SVG generator
  </h1>

  <!-- Samlet boks -->
  <div class="bg-white rounded-lg shadow-md p-6 space-y-8">
    <!-- Knapper -->
    <div>
      <h2 class="text-xl font-bold mb-4">Generer din sang vibe:</h2>
      <div class="flex flex-wrap gap-4">
        <button 
          id="startMic"
          class="bg-green-900 hover:bg-green-800 text-white font-bold py-2 px-4 rounded disabled:bg-gray-300 disabled:cursor-not-allowed">
          ‚ñ∂ Start mikrofon
        </button>
        <button 
          id="stopMic"
          disabled
          class="bg-red-900 hover:bg-red-800 text-white font-bold py-2 px-4 rounded disabled:bg-gray-300 disabled:cursor-not-allowed">
          ‚èπ Stop mikrofon
        </button>
      </div>
    </div>

    <!-- Fil upload -->
    <div>
      <label class="block text-sm font-medium mb-2">üìÅ Upload lydfil (valgfrit)</label>
      <input 
        type="file" 
        id="fileInput" 
        accept="audio/*"
        class="block w-full text-sm text-gray-500
               file:mr-4 file:py-2 file:px-4 file:rounded
               file:border-0 file:text-sm file:font-semibold
               file:bg-gray-400 file:text-white hover:file:bg-gray-300"
      />
    </div>

    <!-- Slider -->
    <div>
      <label class="block text-sm font-medium mb-2">
        ‚è±Ô∏è Hastighed: <span id="speedDisplay">200</span> ms
      </label>
      <input 
        id="intervalMs"
        type="range"
        value="200"
        min="50"
        max="1000"
        step="50"
        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
        style="accent-color: #9ca3af;"
      />
    </div>

    <!-- Tone info -->
    <div>
      <h2 class="text-xl font-semibold mb-4">Registreret tone</h2>
      <div class="grid grid-cols-2 gap-4">
        <div>
          <p class="text-sm text-[#6E63A1]">Tone:</p>
          <p class="text-3xl font-bold text-[#6E63A1]" id="detectedNote">‚Äî</p>
        </div>
        <div>
          <p class="text-sm text-[#6E63A1]">Frekvens:</p>
          <p class="text-3xl font-bold text-[#6E63A1]">
            <span id="detectedFreq">‚Äî</span> Hz
          </p>
        </div>
      </div>
    </div>
  </div>

  <!-- A4 hvor SVG ikoner vises -->
  <div class="bg-white rounded-lg shadow-md p-6 mt-8">
    <h2 class="text-xl font-semibold mb-4">Dit musikstykke</h2>

    <!-- Gem A4 som PNG knap -->
    <button 
      id="savePng"
      class="bg-gray-400 hover:bg-gray-300 text-white font-semibold p-2 px-3 rounded m-4">
      üíæ Gem som PNG
    </button>

    <!-- A4 fast st√∏rrelse -->
    <div 
      id="paper" 
      class="bg-gray-50 p-4 rounded relative overflow-hidden"
      style="width: 794px; height: 1123px; margin: auto; border: 1px solid #ddd;">
    </div>
  </div>

  <script type="module">
    // ==========================================
    // KONSTANTER
    // ==========================================
    const NOTE_SVG_MAP = {
      "C": "/doodles/C.svg",
      "C#": "/doodles/Ckryds.svg",
      "D": "/doodles/D.svg",
      "D#": "/doodles/Dkryds.svg",
      "E": "/doodles/E.svg",
      "F": "/doodles/F.svg",
      "F#": "/doodles/Fkryds.svg",
      "G": "/doodles/G.svg",
      "G#": "/doodles/Gkryds.svg",
      "A": "/doodles/A.svg",
      "A#": "/doodles/Akryds.svg",
      "B": "/doodles/B.svg"
    };

    const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const MIN_TIME_BETWEEN_NOTES = 100;
    const CHUNK_SIZE = 2048;
    const RMS_THRESHOLD = 0.01;
    const CORRELATION_THRESHOLD = 0.9;
    const MIN_SVG_SIZE = 10;
    const MAX_SVG_SIZE = 500;

    // ==========================================
    // DOM ELEMENTER
    // ==========================================
    const startMicBtn = document.getElementById("startMic");
    const stopMicBtn = document.getElementById("stopMic");
    const fileInput = document.getElementById("fileInput");
    const paper = document.getElementById("paper");
    const detectedNoteEl = document.getElementById("detectedNote");
    const detectedFreqEl = document.getElementById("detectedFreq");
    const intervalInput = document.getElementById("intervalMs");
    const speedDisplay = document.getElementById("speedDisplay");

    // ==========================================
    // GLOBALE VARIABLER
    // ==========================================
    let audioContext;
    let mediaStreamSource;
    let scriptProcessor;
    let micStream;

    // ==========================================
    // HJ√ÜLPEFUNKTIONER
    // ==========================================
    
    function freqToNoteName(frequency) {
      if (!frequency || frequency <= 0) return null;
      const midi = Math.round(12 * (Math.log2(frequency / 440)) + 69);
      const noteIndex = midi % 12;
      return { name: NOTE_NAMES[noteIndex], midi };
    }

    function autoCorrelate(buffer, sampleRate) {
      const SIZE = buffer.length;
      
      // Beregn RMS
      let rms = 0;
      for (let i = 0; i < SIZE; i++) {
        rms += buffer[i] * buffer[i];
      }
      rms = Math.sqrt(rms / SIZE);
      
      if (rms < RMS_THRESHOLD) return -1;

      // Find bedste correlation
      let bestOffset = -1;
      let bestCorrelation = 0;
      let lastCorrelation = 1;
      const minOffset = Math.floor(sampleRate / 1000);
      const maxOffset = Math.floor(sampleRate / 50);

      for (let offset = minOffset; offset < maxOffset; offset++) {
        let correlation = 0;
        for (let i = 0; i < SIZE - offset; i++) {
          correlation += Math.abs(buffer[i] - buffer[i + offset]);
        }
        correlation = 1 - (correlation / SIZE);
        
        if (correlation > CORRELATION_THRESHOLD && correlation > lastCorrelation) {
          if (correlation > bestCorrelation) {
            bestCorrelation = correlation;
            bestOffset = offset;
          }
        }
        lastCorrelation = correlation;
      }
      
      if (bestOffset !== -1 && bestCorrelation > CORRELATION_THRESHOLD) {
        return sampleRate / bestOffset;
      }
      return -1;
    }

    async function getSvgForNote(name) {
      const path = NOTE_SVG_MAP[name];
      if (!path) return null;
      
      try {
        const res = await fetch(path);
        if (!res.ok) return null;
        return await res.text();
      } catch (e) {
        console.error("Kunne ikke hente SVG:", e);
        return null;
      }
    }

    async function renderNoteOnPaper(name) {
      const svgHtml = await getSvgForNote(name);
      const wrapper = document.createElement("div");
      
      if (!svgHtml) {
        // Fallback SVG
        wrapper.innerHTML = `
          <svg viewBox="0 0 50 50">
            <rect x="5" y="5" width="40" height="40" rx="8" fill="#1E1E1E"/>
            <text x="25" y="32" font-size="14" font-weight="bold" text-anchor="middle" fill="white">${name}</text>
          </svg>
        `;
      } else {
        wrapper.innerHTML = svgHtml;
      }

      const svgEl = wrapper.firstElementChild;
      if (!svgEl) return;

      // Beregn position og st√∏rrelse - SVG'er kan nu g√• helt ud til kanterne
      const size = Math.floor(Math.random() * (MAX_SVG_SIZE - MIN_SVG_SIZE) + MIN_SVG_SIZE);
      const maxLeft = 794; // A4 bredde
      const maxTop = 1123; // A4 h√∏jde
      const left = Math.random() * maxLeft;
      const top = Math.random() * maxTop;

      // Style SVG element
      Object.assign(svgEl.style, {
        position: "absolute",
        width: `${size}px`,
        height: `${size}px`,
        left: `${left}px`,
        top: `${top}px`,
        animation: "slideIn 0.3s ease-out"
      });

      paper.appendChild(svgEl);
    }

    function updateDetected(name, freq) {
      detectedNoteEl.textContent = name;
      detectedFreqEl.textContent = freq.toFixed(1);
    }

    // ==========================================
    // MIKROFON FUNKTIONER
    // ==========================================
    
    async function startMic() {
      try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new AudioContext();
        mediaStreamSource = audioContext.createMediaStreamSource(micStream);
        scriptProcessor = audioContext.createScriptProcessor(CHUNK_SIZE, 1, 1);
        
        mediaStreamSource.connect(scriptProcessor);
        scriptProcessor.connect(audioContext.destination);

        let lastNoteTime = 0;

        scriptProcessor.onaudioprocess = async (e) => {
          const buffer = e.inputBuffer.getChannelData(0);
          const now = Date.now();
          
          if (now - lastNoteTime < MIN_TIME_BETWEEN_NOTES) return;

          const freq = autoCorrelate(buffer, audioContext.sampleRate);
          if (freq > 0) {
            const note = freqToNoteName(freq);
            if (note?.name) {
              await renderNoteOnPaper(note.name);
              updateDetected(note.name, freq);
              lastNoteTime = now;
            }
          }
        };

        startMicBtn.disabled = true;
        stopMicBtn.disabled = false;
      } catch (e) {
        console.error("Mikrofon fejl:", e);
        alert("Kunne ikke f√• adgang til mikrofonen.");
      }
    }

    function stopMic() {
      scriptProcessor?.disconnect();
      mediaStreamSource?.disconnect();
      micStream?.getTracks().forEach(t => t.stop());
      audioContext?.close();
      
      startMicBtn.disabled = false;
      stopMicBtn.disabled = true;
    }

    // ==========================================
    // FIL PROCESSING
    // ==========================================
    
    async function processAudioBuffer(audioBuffer) {
      const rate = audioBuffer.sampleRate;
      const data = audioBuffer.getChannelData(0);
      const interval = parseInt(intervalInput.value);

      for (let i = 0; i < data.length; i += CHUNK_SIZE) {
        const slice = data.slice(i, i + CHUNK_SIZE);
        const freq = autoCorrelate(slice, rate);
        
        if (freq > 0) {
          const note = freqToNoteName(freq);
          if (note) {
            await renderNoteOnPaper(note.name);
            updateDetected(note.name, freq);
            await new Promise(res => setTimeout(res, interval));
          }
        }
      }
    }

    // ==========================================
    // EVENT LISTENERS
    // ==========================================
    
    intervalInput.addEventListener("input", (e) => {
      speedDisplay.textContent = e.target.value;
    });

    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const arrayBuf = await file.arrayBuffer();
        audioContext = new AudioContext();
        const audioBuf = await audioContext.decodeAudioData(arrayBuf);
        await processAudioBuffer(audioBuf);
      } catch (e) {
        console.error("Fil fejl:", e);
        alert("Kunne ikke l√¶se lydfilen.");
      }
    });

    startMicBtn.addEventListener("click", startMic);
    stopMicBtn.addEventListener("click", stopMic);

    // ==========================================
    // GEM SOM PNG
    // ==========================================
    
    const savePngBtn = document.getElementById("savePng");
    
    savePngBtn.addEventListener("click", async () => {
      try {
        savePngBtn.disabled = true;
        savePngBtn.textContent = "üíæ Gemmer...";
        
        // Opret et nyt canvas
        const canvas = document.createElement('canvas');
        canvas.width = 794;
        canvas.height = 1123;
        const ctx = canvas.getContext('2d');
        
        // Fyld baggrund
        ctx.fillStyle = '#f9fafb';
        ctx.fillRect(0, 0, 794, 1123);
        
        // Tegn alle SVG'er
        const svgs = paper.querySelectorAll('svg');
        
        for (const svg of svgs) {
          const rect = svg.getBoundingClientRect();
          const paperRect = paper.getBoundingClientRect();
          
          const x = rect.left - paperRect.left;
          const y = rect.top - paperRect.top;
          const width = parseFloat(svg.style.width);
          const height = parseFloat(svg.style.height);
          
          // Serialiser SVG til string
          const svgString = new XMLSerializer().serializeToString(svg);
          const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(svgBlob);
          
          // Load som image
          const img = new Image();
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = url;
          });
          
          // Tegn p√• canvas
          ctx.drawImage(img, x, y, width, height);
          URL.revokeObjectURL(url);
        }
        
        // Download
        canvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
          link.download = `musikstykke-${timestamp}.png`;
          link.href = url;
          link.click();
          URL.revokeObjectURL(url);
        });
        
        savePngBtn.disabled = false;
        savePngBtn.textContent = "üíæ Gem som PNG";
        
      } catch (e) {
        console.error("PNG fejl:", e);
        alert("Kunne ikke gemme som PNG: " + e.message);
        savePngBtn.disabled = false;
        savePngBtn.textContent = "üíæ Gem som PNG";
      }
    });
  </script>
</Layout>