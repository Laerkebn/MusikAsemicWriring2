---
import Layout from "../layouts/Layout.astro";
import "../styles.css";
import Udseene from "./udseene.astro";
import Soft from "./soft.astro";
import Rough from "./rough.astro";
---

<!DOCTYPE html>
<html lang="da">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tone → SVG Generator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    body {
      background: linear-gradient(135deg, #131313 0%, #FFFFF0 100%);
      min-height: 100vh;
      padding: 2rem;
    }
    .style-btn {
      transition: all 0.2s ease;
    }
    .style-btn.active {
      background-color: #1E1E1E !important;
      color: white !important;
      transform: scale(1.05);
    }
    .style-btn:disabled {
      cursor: not-allowed;
    }
  </style>
</head>
<body>
    <Soft />
    <Rough />
    <Udseene />



  <script type="module">
    
    // ==========================================
    // KONSTANTER
    // ==========================================
    let NOTE_SVG_MAP = window.ROUGH_STYLE_MAP; // Start med rough style
    let currentStyle = 'rough';

    const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const MIN_TIME_BETWEEN_NOTES = 100;
    const CHUNK_SIZE = 2048;
    const RMS_THRESHOLD = 0.01;
    const CORRELATION_THRESHOLD = 0.9;
    const MIN_SVG_SIZE = 10;
    const MAX_SVG_SIZE = 300;

    // ==========================================
    // DOM ELEMENTER
    // ==========================================
    const startMicBtn = document.getElementById("startMic");
    const stopMicBtn = document.getElementById("stopMic");
    const fileInput = document.getElementById("fileInput");
    const paper = document.getElementById("paper");
    const detectedNoteEl = document.getElementById("detectedNote");
    const centerTextEl = document.getElementById("centerText");
    const detectedFreqEl = document.getElementById("detectedFreq");
    const intervalInput = document.getElementById("intervalMs");
    const speedDisplay = document.getElementById("speedDisplay");
    const colorPicker = document.getElementById("colorPicker");
    const softStyleBtn = document.getElementById("softStyleBtn");
    const roughStyleBtn = document.getElementById("roughStyleBtn");

    // ==========================================
    // GLOBALE VARIABLER
    // ==========================================
    let audioContext;
    let mediaStreamSource;
    let scriptProcessor;
    let micStream;
    let currentColor = "#1E1E1E";

    // ==========================================
    // STYLE SWITCHING
    // ==========================================
    
    function switchStyle(style) {
      // STEP 1: Gem hvilken style der er valgt (enten 'soft' eller 'rough')
      currentStyle = style;
      
      // STEP 2: Tjek om brugeren har klikket på "Soft aesthetic" knappen
      if (style === 'soft') {
        
        // STEP 3: Skift til soft style SVG
        NOTE_SVG_MAP = window.SOFT_STYLE_MAP;
        
        // STEP 4: Style "Soft aesthetic" knappen som AKTIV
        softStyleBtn.style.backgroundColor = '#9DA2AE';  
        softStyleBtn.style.color = '#FFFFF1';            
        softStyleBtn.disabled = true;                  
        
        // STEP 5: Style "Rough aesthetic" knappen som INAKTIV
        roughStyleBtn.style.backgroundColor = '#D1D5DC'; 
        roughStyleBtn.style.color = '#FFFFF1';         
        roughStyleBtn.disabled = false;                
        
      } else {
        // STEP 6: Brugeren har klikket på "Rough aesthetic" knappen
        // STEP 7: Skift til rough style SVG'erne 
        NOTE_SVG_MAP = window.ROUGH_STYLE_MAP;
        
        // STEP 8: Style "Rough aesthetic" knappen som AKTIV
        roughStyleBtn.style.backgroundColor = '#9DA2AE';
        roughStyleBtn.style.color = '#FFFFF1';
        roughStyleBtn.disabled = true;
        
        // STEP 9: Style "Soft aesthetic" knappen som INAKTIV
        softStyleBtn.style.backgroundColor = '#D1D5DC';
        softStyleBtn.style.color = '#FFFFF1';
        softStyleBtn.disabled = false;
      }
      
      // STEP 10: Log til console så vi kan se det virker (kun for debugging)
      console.log(`Skiftet til ${style} style`);
    }

  
    // ==========================================
    // HJÆLPEFUNKTIONER
    // ==========================================
    function freqToNoteName(frequency) {
      if (!frequency || frequency <= 0) return null;
      const midi = Math.round(12 * (Math.log2(frequency / 440)) + 69);
      const noteIndex = midi % 12;
      return { name: NOTE_NAMES[noteIndex], midi };
    }

    function autoCorrelate(buffer, sampleRate) {
      const SIZE = buffer.length;
      
      // Beregn RMS
      let rms = 0;
      for (let i = 0; i < SIZE; i++) {
        rms += buffer[i] * buffer[i];
      }
      rms = Math.sqrt(rms / SIZE);
      
      if (rms < RMS_THRESHOLD) return -1;

      // Find bedste correlation
      let bestOffset = -1;
      let bestCorrelation = 0;
      let lastCorrelation = 1;
      const minOffset = Math.floor(sampleRate / 1000);
      const maxOffset = Math.floor(sampleRate / 50);

      for (let offset = minOffset; offset < maxOffset; offset++) {
        let correlation = 0;
        for (let i = 0; i < SIZE - offset; i++) {
          correlation += Math.abs(buffer[i] - buffer[i + offset]);
        }
        correlation = 1 - (correlation / SIZE);
        
        if (correlation > CORRELATION_THRESHOLD && correlation > lastCorrelation) {
          if (correlation > bestCorrelation) {
            bestCorrelation = correlation;
            bestOffset = offset;
          }
        }
        lastCorrelation = correlation;
      }
      
      if (bestOffset !== -1 && bestCorrelation > CORRELATION_THRESHOLD) {
        return sampleRate / bestOffset;
      }
      return -1;
    }

    async function getSvgForNote(name) {
      const path = NOTE_SVG_MAP[name];
      if (!path) return null;
      
      try {
        const res = await fetch(path);
        if (!res.ok) return null;
        return await res.text();
      } catch (e) {
        console.error("Kunne ikke hente SVG:", e);
        return null;
      }
    }

    async function renderNoteOnPaper(name) {
      const svgHtml = await getSvgForNote(name);
      const wrapper = document.createElement("div");
      


      // "Frys" farven for denne specifikke SVG
      const frozenColor = currentColor;
      
      if (!svgHtml) {
        // Fallback SVG med valgt farve
        wrapper.innerHTML = `
          <svg viewBox="0 0 50 50">
            <rect x="5" y="5" width="40" height="40" rx="8" fill="${frozenColor}"/>
            <text x="25" y="32" font-size="14" font-weight="bold" text-anchor="middle" fill="white">${name}</text>
          </svg>
        `;
      } else {
        wrapper.innerHTML = svgHtml;
      }

      const svgEl = wrapper.firstElementChild;
      if (!svgEl) return;

      // Fjern eksisterende <style> tags (de påvirker alle SVG'er)
      const existingStyles = svgEl.querySelectorAll('style');
      existingStyles.forEach(style => style.remove());

      // Sæt farve DIREKTE på hvert element
      const allElements = svgEl.querySelectorAll('path, line, polyline, polygon, circle, rect, ellipse, g');
      allElements.forEach(el => {
        el.setAttribute('stroke', frozenColor);
        el.setAttribute('fill', 'none');
        el.removeAttribute('class');
      });

  // Beregn position og størrelse
  const size = Math.floor(Math.random() * (MAX_SVG_SIZE - MIN_SVG_SIZE) + MIN_SVG_SIZE);

  // Papirstørrelse (samme som #paper)
  const paperWidth = 1123;
  const paperHeight = 794;
  // Hvor meget SVG'er må stikke udenfor kanten
  const bleedX = 150;
  const bleedY = 150;

// Tillad -bleed → paperWidth/Height positions
const left = Math.random() * (paperWidth + bleedX) - bleedX;
const top  = Math.random() * (paperHeight + bleedY) - bleedY;


      // Style SVG element
      Object.assign(svgEl.style, {
        position: "absolute",
        width: `${size}px`,
        height: `${size}px`,
        left: `${left}px`,
        top: `${top}px`,
        animation: "slideIn 0.3s ease-out"
      });

      paper.appendChild(svgEl);
    }

    function updateDetected(name, freq) {
      detectedNoteEl.textContent = name;
      detectedFreqEl.textContent = freq.toFixed(1);
    }

    // ==========================================
    // MIKROFON FUNKTIONER
    // ==========================================
    
    async function startMic() {
      try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new AudioContext();
        mediaStreamSource = audioContext.createMediaStreamSource(micStream);
        scriptProcessor = audioContext.createScriptProcessor(CHUNK_SIZE, 1, 1);
        
        mediaStreamSource.connect(scriptProcessor);
        scriptProcessor.connect(audioContext.destination);

        let lastNoteTime = 0;

        scriptProcessor.onaudioprocess = async (e) => {
          const buffer = e.inputBuffer.getChannelData(0);
          const now = Date.now();
          
          if (now - lastNoteTime < MIN_TIME_BETWEEN_NOTES) return;

          const freq = autoCorrelate(buffer, audioContext.sampleRate);
          if (freq > 0) {
            const note = freqToNoteName(freq);
            if (note?.name) {
              await renderNoteOnPaper(note.name);
              updateDetected(note.name, freq);
              lastNoteTime = now;
            }
          }
        };

        startMicBtn.disabled = true;
        stopMicBtn.disabled = false;
      } catch (e) {
        console.error("Mikrofon fejl:", e);
        alert("Kunne ikke få adgang til mikrofonen.");
      }
    }

    function stopMic() {
      scriptProcessor?.disconnect();
      mediaStreamSource?.disconnect();
      micStream?.getTracks().forEach(t => t.stop());
      audioContext?.close();
      
      startMicBtn.disabled = false;
      stopMicBtn.disabled = true;
    }

    // ==========================================
    // FIL PROCESSING
    // ==========================================
    
    async function processAudioBuffer(audioBuffer) {
      const rate = audioBuffer.sampleRate;
      const data = audioBuffer.getChannelData(0);
      const interval = parseInt(intervalInput.value);

      for (let i = 0; i < data.length; i += CHUNK_SIZE) {
        const slice = data.slice(i, i + CHUNK_SIZE);
        const freq = autoCorrelate(slice, rate);
        
        if (freq > 0) {
          const note = freqToNoteName(freq);
          if (note) {
            await renderNoteOnPaper(note.name);
            updateDetected(note.name, freq);
            await new Promise(res => setTimeout(res, interval));
          }
        }
      }
    }

    // ==========================================
    // EVENT LISTENERS
    // ==========================================
    
    colorPicker.addEventListener("input", (e) => {
      currentColor = e.target.value;
    });
    
    intervalInput.addEventListener("input", (e) => {
      speedDisplay.textContent = e.target.value;
    });

    softStyleBtn.addEventListener("click", () => switchStyle('soft'));
    roughStyleBtn.addEventListener("click", () => switchStyle('rough'));

    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const arrayBuf = await file.arrayBuffer();
        audioContext = new AudioContext();
        const audioBuf = await audioContext.decodeAudioData(arrayBuf);
        await processAudioBuffer(audioBuf);
      } catch (e) {
        console.error("Fil fejl:", e);
        alert("Kunne ikke læse lydfilen.");
      }
    });

    startMicBtn.addEventListener("click", startMic);
    stopMicBtn.addEventListener("click", stopMic);

    // ==========================================
    // GEM SOM SVG
    // ==========================================
    
    const saveSvgBtn = document.getElementById("saveSvg");

saveSvgBtn.addEventListener("click", () => {
  try {
    // Brug samme størrelse som #paper (liggende A4)
    const PAPER_WIDTH = 1123;
    const PAPER_HEIGHT = 794;

    const svgWrapper = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svgWrapper.setAttribute("width", PAPER_WIDTH);
    svgWrapper.setAttribute("height", PAPER_HEIGHT);
    svgWrapper.setAttribute("viewBox", `0 0 ${PAPER_WIDTH} ${PAPER_HEIGHT}`);
    svgWrapper.setAttribute("xmlns", "http://www.w3.org/2000/svg");

    // Baggrund
    const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    bg.setAttribute("width", PAPER_WIDTH);
    bg.setAttribute("height", PAPER_HEIGHT);
    bg.setAttribute("fill", "#f9fafb");
    svgWrapper.appendChild(bg);

    // Alle doodle-SVG'er
    const svgs = paper.querySelectorAll("svg");
    svgs.forEach((svg) => {
      const x = parseFloat(svg.style.left) || 0;
      const y = parseFloat(svg.style.top) || 0;
      const width = parseFloat(svg.style.width) || 50;

      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g.setAttribute("transform", `translate(${x}, ${y})`);

      const viewBox = svg.getAttribute("viewBox") || "0 0 50 50";
      const [, , vbW] = viewBox.split(" ").map(Number);
      const scale = width / vbW;

      const innerG = document.createElementNS("http://www.w3.org/2000/svg", "g");
      innerG.setAttribute("transform", `scale(${scale})`);

      Array.from(svg.children).forEach((child) => {
        innerG.appendChild(child.cloneNode(true));
      });

      g.appendChild(innerG);
      svgWrapper.appendChild(g);
    });

    // ==============================
    // Navn + hvid boks i midten
    // ==============================
    if (centerTextEl) {
      let nameText = "";

      // Virker både hvis det er <textarea> eller <div contenteditable>
      if (
        centerTextEl.tagName === "TEXTAREA" ||
        centerTextEl.tagName === "INPUT"
      ) {
        nameText = centerTextEl.value.trim();
      } else {
        nameText = centerTextEl.textContent.trim();
      }

      if (nameText) {
  const paperRect = paper.getBoundingClientRect();
  const textRect = centerTextEl.getBoundingClientRect();

  // Position inde i HTML-papiret
  const rawX = textRect.left - paperRect.left;
  const rawY = textRect.top - paperRect.top;

  // HTML-pixels -> SVG-koordinater
  const scaleX = PAPER_WIDTH / paperRect.width;
  const scaleY = PAPER_HEIGHT / paperRect.height;

  const svgX = rawX * scaleX;
  const svgY = rawY * scaleY;
  const svgWidth = textRect.width * scaleX;
  const svgHeight = textRect.height * scaleY;

  // Hvid boks bag navnet
  const nameBg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  nameBg.setAttribute("x", svgX);
  nameBg.setAttribute("y", svgY);
  nameBg.setAttribute("width", svgWidth);
  nameBg.setAttribute("height", svgHeight);
  nameBg.setAttribute("rx", 12);
  nameBg.setAttribute("ry", 12);
  nameBg.setAttribute("fill", "#ffffff");
  svgWrapper.appendChild(nameBg);

  // Selve navnet i midten
  const nameTextElSvg = document.createElementNS("http://www.w3.org/2000/svg", "text");
  nameTextElSvg.textContent = nameText;
  nameTextElSvg.setAttribute("x", svgX + svgWidth / 2);
  nameTextElSvg.setAttribute("y", svgY + svgHeight / 2);
  nameTextElSvg.setAttribute("text-anchor", "middle");
  nameTextElSvg.setAttribute("dominant-baseline", "middle");
  nameTextElSvg.setAttribute("fill", "#111827");
  nameTextElSvg.setAttribute("font-size", "72");
  nameTextElSvg.setAttribute("font-family", "'Acumin Pro Condensed', sans-serif");
  nameTextElSvg.setAttribute("font-weight", "700");
  svgWrapper.appendChild(nameTextElSvg);
}

    }

    // Gem som fil
    const svgString = new XMLSerializer().serializeToString(svgWrapper);
    const blob = new Blob([svgString], {
      type: "image/svg+xml;charset=utf-8",
    });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, "-");
    link.download = `musikstykke-${currentStyle}-${timestamp}.svg`;
    link.href = url;
    link.click();
    URL.revokeObjectURL(url);
  } catch (e) {
    console.error("SVG fejl:", e);
    alert("Kunne ikke gemme som SVG: " + e.message);
  }
});


    // Initialiser med rough style som aktiv ved opstart
    roughStyleBtn.style.backgroundColor = '#9DA2AE';
    roughStyleBtn.style.color = '#FFFFF1';
    roughStyleBtn.disabled = true;
    
    softStyleBtn.style.backgroundColor = '#D1D5DC';
    softStyleBtn.style.color = '#FFFFF1';
    softStyleBtn.disabled = false;
  </script>
</body>
</html>